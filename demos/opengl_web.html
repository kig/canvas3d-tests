<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>OpenGL for the web</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<script type="application/x-javascript" src="../util.js"></script>

    <script type="application/x-javascript">

function log(msg) {
  document.getElementById('note').textContent += "\n"+msg;
}




function init(ev) {
    var canvas = document.getElementById('canvas');
    var gl = canvas.getContext('moz-glweb20');

    var shader = new Shader(gl, "ppix-vert", "ppix-frag");
    shader.compile();
    var fbo = new FBO(gl, canvas.width, canvas.height);
    var fbo2 = new FBO(gl, canvas.width, canvas.height);
    var fbo3 = new FBO(gl, canvas.width, canvas.height);
    var depth = new Shader(gl, "depth-vert", "depth-frag");
    var identity = new Filter(gl, "identity-vert", "identity-frag");
    var unpremult = new Filter(gl, "identity-vert", "unpremult-frag");
    var hblur = new Filter(gl, "identity-vert", "hblur-frag");
    var vblur = new Filter(gl, "identity-vert", "vblur-frag");
    var hdof = new Filter(gl, "identity-vert", "hdof-frag");
    var vdof = new Filter(gl, "identity-vert", "vdof-frag");

    redraw(canvas, gl, shader, fbo, fbo2, fbo3, depth, identity, unpremult, hblur, vblur, hdof, vdof);

    setInterval(function(){
        redraw(canvas, gl, shader, fbo, fbo2, fbo3, depth, identity, unpremult, hblur, vblur, hdof, vdof);
    }, 33);
}

function drawCube (gl, shader, angle, axis, x,y,z, s, va, na, ta) {
    var rot = Matrix.rotate(angle, axis);
    var trans = Matrix.translate3(x,y,z);
    var sca = Matrix.scale1(s);
    Matrix.mul4x4InPlace(Matrix.identity, look, vmat);
    Matrix.mul4x4InPlace(vmat, trans, vmat2);
    Matrix.mul4x4InPlace(vmat2, sca, vmat);
    Matrix.mul4x4InPlace(vmat, rot, vmat2);

    shader.uniformMatrix("MVMatrix", vmat2);

    var cube = Cube.getCachedVBO(gl);
    cube.draw(va, na, ta);
}

function drawScene (gl, shader, va, na, ta) {
    var t = new Date().getTime();

    shader.uniformMatrix("PMatrix", pmat);

    drawCube(gl, shader,
              (t/400) % (2*Math.PI), [0, 1, 1],
              0, -0.1+Math.cos(t/1000)*1, Math.sin(t/1000)*3,
              0.6,
              va, na, ta);
    drawCube(gl, shader,
              (t/350) % (2*Math.PI), [0, 1.2, 1],
              0.6, -0.1+Math.cos((t*1.4+120)/1000)*1, Math.sin((t*1.4+120)/1000)*3,
              0.25,
              va, na, ta);
    drawCube(gl, shader,
              (-t/250) % (2*Math.PI), [0.2, 1.2, 1],
              0.9, -0.1+Math.cos((t*1.2-120)/1000)*1, Math.sin((t*1.2-120)/1000)*4,
              0.15,
              va, na, ta);
}

var vmat = new Array(16);
var vmat2 = new Array(16);
var pmat;
var look = Matrix.lookAt([4,-1,8], [-0.2,0,0], [0,1,0]);

function redraw(canvas, gl, shader, fbo, fbo2, fbo3, depth, identity, unpremult, hblur, vblur, hdof, vdof) {
//     return
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.enable(gl.DEPTH_TEST);

    gl.bindFramebuffer(gl.FRAMEBUFFER, 0);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    fbo.use();

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    shader.use();

    var va = shader.attrib("Vertex");
    var na = shader.attrib("Normal");
    var ta = shader.attrib("Tex");

    if (pmat == null)
        pmat = Matrix.perspective(30, canvas.width/canvas.height, 1, 100);

    shader.uniformf("MaterialSpecular", [0.95, 0.9, 0.6, 1]);
    shader.uniformf("MaterialDiffuse", [0.50, 0.35, 0.35, 1]);
    shader.uniformf("MaterialAmbient", [0.0, 0.1, 0.2, 1]);
    shader.uniformf("MaterialShininess", [1.5]);

    shader.uniformf("GlobalAmbient", [0.1, 0.1, 0.1, 1]);

    shader.uniformf("LightPos", [1, 5, 3, 1.0]);

    shader.uniformf("LightSpecular", [0.9, 0.9, 0.9, 1]);
    shader.uniformf("LightDiffuse", [0.8, 0.8, 0.8, 1]);
    shader.uniformf("LightAmbient", [0.0, 0.06, 0.2, 1]);
    shader.uniformf("LightConstantAtt", [0.0]);
    shader.uniformf("LightLinearAtt", [0.1]);
    shader.uniformf("LightQuadraticAtt", [0.0]);


    drawScene(gl, shader, va, na);

    fbo3.use();
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    depth.use();
    var dva = depth.attrib("Vertex");
    
    drawScene(gl, depth, dva);


    gl.disable(gl.DEPTH_TEST);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, fbo3.texture);
    gl.activeTexture(gl.TEXTURE0);

    gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
    fbo2.use();
    hblur.apply(function(f){
      f.uniformi("Texture", [0]);
      f.uniformf("step", [1.0/canvas.width]);
    });

    gl.bindTexture(gl.TEXTURE_2D, fbo2.texture);
    fbo.use();
    vblur.apply(function(f){
      f.uniformi("Texture", [0]);
      f.uniformf("step", [1/canvas.width]);
    });

    for (var i=0; i<5; i++) {
      gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
      fbo2.use();
      hdof.apply(function(f){
        f.uniformi("Texture", [0]);
        f.uniformi("Depth", [1]);
        f.uniformf("iter", [i]);
        f.uniformf("step", [1.0/canvas.width]);
      });

      gl.bindTexture(gl.TEXTURE_2D, fbo2.texture);
      fbo.use();
      vdof.apply(function(f){
        f.uniformi("Texture", [0]);
        f.uniformi("Depth", [1]);
        f.uniformf("iter", [i]);
        f.uniformf("step", [1.0/canvas.width]);
      });
    }

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, 0);
    gl.activeTexture(gl.TEXTURE0);

    gl.bindFramebuffer(gl.FRAMEBUFFER, 0);
    gl.bindTexture(gl.TEXTURE_2D, fbo.texture);

    unpremult.apply();

    gl.swapBuffers();
}

window.addEventListener("load", init, false);
    </script>

    <script id="ppix-vert" type="x-shader/x-vertex">
      attribute vec3 Vertex;
      attribute vec3 Normal;
      attribute vec2 Tex;

      uniform mat4 PMatrix;
      uniform mat4 MVMatrix;

      uniform vec4 MaterialAmbient;
      uniform vec4 MaterialDiffuse;

      uniform vec4 LightAmbient;
      uniform vec4 LightDiffuse;
      
      uniform vec4 GlobalAmbient;

      uniform vec4 LightPos;

      varying vec4 diffuse, ambientGlobal, ambient;
      varying vec3 normal, lightDir, halfVector;
      varying float dist;

      void main()
      {
        vec4 worldPos;
        vec3 lightVector;
        vec4 v = vec4(Vertex, 1.0);

        /* transform vertex normal into world space and normalize */
        normal = normalize(mat3(MVMatrix) * Normal);

        /* transform vertex into world space and compute the vector
          from it to the light */
        worldPos = MVMatrix * v;
        lightVector = vec3(LightPos - worldPos);
        lightDir = normalize(lightVector);
        dist = length(lightVector);

        /* Half-vector used in Blinn-Phong shading due to computational efficiency */
        halfVector = normalize(lightVector - vec3(worldPos));

        diffuse = MaterialDiffuse * LightDiffuse;

        /* The ambient terms have been separated since one of them */
        /* suffers attenuation */
        ambient = MaterialAmbient * LightAmbient;
        ambientGlobal = GlobalAmbient * MaterialAmbient;

        gl_Position = PMatrix * worldPos;
      }
    </script>

    <script id="ppix-frag" type="x-shader/x-fragment">
      uniform vec4 LightSpecular;
      uniform vec4 MaterialSpecular;
      uniform float MaterialShininess;

      uniform float LightConstantAtt;
      uniform float LightLinearAtt;
      uniform float LightQuadraticAtt;

      varying vec4 diffuse,ambientGlobal, ambient;
      varying vec3 normal, lightDir, halfVector;
      varying float dist;

      void main()
      {
        vec3 n, halfV, viewV, ldir;
        float NdotL, NdotHV;
        vec4 color = ambientGlobal;
        float att;

        n = normalize(normal);

        NdotL = max(dot(n, normalize(lightDir)), 0.0);

        if (NdotL > 0.0) {

          att = 1.0 / (LightConstantAtt + LightLinearAtt * dist + LightQuadraticAtt * dist * dist);

          color += att * (diffuse * NdotL + ambient);

          halfV = normalize(halfVector);
          NdotHV = max( dot(normal, halfV), 0.0 );

          color += att * MaterialSpecular * LightSpecular * pow(NdotHV, MaterialShininess);
        }

        gl_FragColor = color;
      }
    </script>
    <script id="depth-vert" type="x-shader/x-vertex">
      attribute vec3 Vertex;
      uniform mat4 PMatrix;
      uniform mat4 MVMatrix;
      varying float depth;
      void main()
      {
        gl_Position = PMatrix * (MVMatrix * vec4(Vertex, 1.0));
        depth = 1.0-(gl_Position.z / gl_Position.w);
      }
    </script>
    <script id="depth-frag" type="x-shader/x-fragment">
      varying float depth;
      void main()
      {
        vec4 c = vec4(depth, 0.0, 0.0, 1.0);
        gl_FragColor = c;
      }
    </script>

    <script id="identity-vert" type="x-shader/x-vertex">
      #version 120
      attribute vec3 Vertex;
      attribute vec2 Tex;

      varying vec4 texCoord0;
      void main()
      {
        texCoord0 = vec4(Tex,0.0,0.0);
        gl_Position = vec4(Vertex, 1.0);
      }
    </script>
    <script id="identity-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;

      varying vec4 texCoord0;
      void main()
      {
        vec4 c = texture2D(Texture, texCoord0.st);
        gl_FragColor = c;
      }
    </script>
    <script id="premult-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;

      varying vec4 texCoord0;
      void main()
      {
        vec4 c = texture2D(Texture, texCoord0.st);
        float a = c.a;
        c *= a;
        c.a = a;
        gl_FragColor = c;
      }
    </script>
    <script id="unpremult-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;

      varying vec4 texCoord0;
      void main()
      {
        vec4 c = texture2D(Texture, texCoord0.st);
        float a = c.a;
        c *= 1.0 / a;
        c.a = a;
        gl_FragColor = c;
      }
    </script>

    <script id="hblur-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;
      uniform float step;
      
      varying vec4 texCoord0;
      void main()
      {
        float kernel[7] = {0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006};
        int i=0;
        if (texture2D(Texture, texCoord0.st).a > 0.0) {
          vec4 sum = vec4(0.0);
          for (i=-3; i<=3; i++) {
            vec4 tmp = texture2D(Texture, texCoord0.st + vec2(i*step,0));
            sum += tmp * kernel[i+3];
          }
          gl_FragColor = sum;
        } else {
          gl_FragColor = texture2D(Texture, texCoord0.st);
        }
      }
    </script>
    <script id="vblur-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;
      uniform float step;

      varying vec4 texCoord0;
      void main()
      {
        float kernel[7] = {0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006};
        int i=0;
        if (texture2D(Texture, texCoord0.st).a > 0.0) {
          vec4 sum = vec4(0.0);
          for (i=-3; i<=3; i++) {
            vec4 tmp = texture2D(Texture, texCoord0.st + vec2(0,i*step));
            sum += tmp * kernel[i+3];
          }
          gl_FragColor = sum;
        } else {
          gl_FragColor = texture2D(Texture, texCoord0.st);
        }
      }
    </script>
    <script id="hdof-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;
      uniform sampler2D Depth;
      uniform float step;
      uniform float iter;

      varying vec4 texCoord0;
      void main()
      {
        float kernel[7] = {0.046, 0.111, 0.202, 0.283, 0.202, 0.111, 0.046};
        int i=0;
        if (iter < -26.0+36.0*(1.0-texture2D(Depth, texCoord0.st).r)
            && texture2D(Texture, texCoord0.st).a > 0.0) {
          vec4 sum = vec4(0.0);
          for (i=-3; i<=3; i++) {
            vec4 tmp = texture2D(Texture, texCoord0.st + vec2((float)i*step,0));
            sum += tmp * kernel[i+3];
          }
          gl_FragColor = sum;
        } else {
          gl_FragColor = texture2D(Texture, texCoord0.st);
        }
      }
    </script>
    <script id="vdof-frag" type="x-shader/x-fragment">
      uniform sampler2D Texture;
      uniform sampler2D Depth;
      uniform float step;
      uniform float iter;

      varying vec4 texCoord0;
      void main()
      {
        float kernel[7] = {0.046, 0.111, 0.202, 0.283, 0.202, 0.111, 0.046};
        int i=0;
        if (iter < -26.0+36.0*(1.0-texture2D(Depth, texCoord0.st).r)
            && texture2D(Texture, texCoord0.st).a > 0.0) {
          vec4 sum = vec4(0.0);
          for (i=-3; i<=3; i++) {
            vec4 tmp = texture2D(Texture, texCoord0.st + vec2(0,(float)i*step));
            sum += tmp * kernel[i+3];
          }
          vec4 ic = vec4((5.0-iter)/5.0);
          ic.a=1.0;
          gl_FragColor = ic+0.1*sum;
          gl_FragColor = sum;
        } else {
          gl_FragColor = texture2D(Texture, texCoord0.st);
        }
      }
    </script>

    <style>
      * { margin: 0px; padding: 0px; }
      html {
        background-color: #707888;
        color: #222222;
      }
      #canvas {
        position: absolute;
        top: 115px; left: 550px;
      }
      #note {
        position: absolute;
        top: 4px;
        left: 4px;
      }
      #content {
        margin-left: 99px;
        padding-left: 8px;
        padding-right: 8px;
        padding-bottom: 16px;
        width: 600px;
        background-color: rgba(255,255,255,1.0);
        text-align: center;
        border-left: 1px solid rgba(0,0,0,0.5);
        border-right: 2px solid rgba(0,0,0,0.75);
      }
      h1 {
        padding-top: 24px;
        padding-bottom: 16px;
        margin-bottom: 24px;
        border-bottom: 1px solid black;
        font-family: Times New Roman, Serif;
        font-weight: bold;
        font-size: 40px;
      }
      #content p {
        text-indent: 24px;
        margin-left: 24px;
        margin-right: 32px;
        text-align: justify;
        font-family: Serif;
        padding-bottom: 16px;
      }
      #above {
        position: absolute;
        top: 300px;
        left: 716px;
        padding: 10px 20px;
        background-color: rgba(0,225,0,0.5);
        border-left: 2px solid rgba(0,64,0,0.75);
        color: white;
        font-size: small;
        font-family: sans-serif;
      }
      #above p {
        text-align: center;
      }
    </style>

</head><body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <pre id="note"></pre>

    <div id="content">
    <h1>OpenGL for the web</h1>
    <p>
      The Canvas 3D extension for Firefox 3 gives web developers access to an OpenGL ES 2.0 drawing context for the canvas tag. What that means is that you can finally harness the power of the GPU for awesome visuals and heavy-duty number crunching in your web apps.
    <p>
      OpenGL ES 2.0 is a subset of OpenGL 2.0 aimed at embedded devices and game consoles. As such, it's a very minimalistic low-level API, even more so than desktop OpenGL. In fact, if you took desktop OpenGL and stripped out everything but shaders, vertex arrays and textures, you'd get something quite like OpenGL ES 2.0.
    </p>
    <p>
      As there is no fixed-function pipeline, you need to write GLSL shaders to draw <i>anything</i>. And you need to do your own transformation math, including keeping track of the transformation matrix stack. So the raw API is really not for the faint of heart; you do need to know your 3D math and shading equations.
    </p>
    <p>
      For example, to draw the spinning cubes on the right - around 200 lines of application code, 250 lines of shaders and 800 lines of library code - I had to scrounge the internet for <a href="http://www.lighthouse3d.com/opengl/glsl/index.php?pointlight">GLSL shaders</a> to do the transformation and lighting, write a small matrix math library in JavaScript and a DoF blur shader. While highly educational, it was also a rather steep hill to climb.
    </p>
    <p>
      So, the intended audience of the raw context interface are not really end-users, but library developers who can write easy-to-use interfaces to the functionality, and 3D developers who require a high level of control over the rendering pipeline.
    </p>
    <p>
      The really cool thing about the OpenGL Canvas is that it doesn't make policy decisions. There's no single set-in-stone use case for it: In addition to 3D graphics, you can also use it for filtering images, visualizing fluid dynamics, doing real-time video effects, or just crunching a whole lot of FP math. If you can do it on the GPU, you're in luck!
    </p>
    </div>
    <div id="above">
      <p>You can also place content above the canvas</p>
    </div>
  </body></html>
