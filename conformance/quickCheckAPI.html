<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../unit.css" />
<script type="application/x-javascript" src="../unit.js"></script>
<script type="application/x-javascript" src="../util.js"></script>

<script type="application/x-javascript">
  /*
    QuickCheck tests for WebGL:

      1. Write a valid arg generator for each function
        1.1. Write valid arg predicates to use with random generator:
             if value passes generator, accept it as valid.
        1.2. Often needs initializing and cleanup:
             setup - generate - cleanup
             gl.createBuffer - test(bindBufferGenerator) - gl.deleteBuffer

      2. Write an invalid arg generator
        2.1. Take valid args, modify an arg until the args no longer pass
             checkArgValidity.
        2.2. Repeat for all args.

      3. Test functions using the generators
        3.1. Args generated with the valid arg generator should pass
             assertOk(f(args))
        3.2. Args generated with the invalid arg generator should pass
             assertFail(f(args))
  */
  GL = document.createElement('canvas').getContext(GL_CONTEXT_ID);
  Array.from = function(o) {
    var a = [];
    for (var i=0; i<o.length; i++)
      a.push(o[i]);
    return a;
  }
  Array.prototype.has = function(v) { return this.indexOf(v) != -1; }
  Array.prototype.random = function() {
    return this[Math.floor(this.length * Math.random())];
  }

  // Creates a constant checker / generator from its arguments.
  // 
  // E.g. if you want a constant checker for the constants 1, 2, and 3, you
  // would do the following:
  // 
  //   var cc = constCheck(1,2,3);
  //   var randomConst = cc.random();
  //   if (cc.has(randomConst))
  //     console.log("randomConst is included in cc's constants");
  // 
  constCheck = function() {
    return Array.from(arguments);
  }

  bufferTarget = constCheck(GL.ARRAY_BUFFER, GL.ELEMENT_ARRAY_BUFFER);
  bufferMode = constCheck(GL.STREAM_DRAW, GL.STATIC_DRAW, GL.DYNAMIC_DRAW);
  cullFace = constCheck(GL.FRONT, GL.BACK, GL.FRONT_AND_BACK);
  shaderType = constCheck(GL.VERTEX_SHADER, GL.FRAGMENT_SHADER);
  textureUnit = constCheck.apply(this, (function(){
    var textureUnits = [];
    var texUnits = GL.getParameter(GL.MAX_TEXTURE_IMAGE_UNITS);
    for (var i=0; i<texUnits; i++) textureUnits.push(GL['TEXTURE'+i]);
    return textureUnits;
  })());

  WebGLArrayTypes = [
    WebGLFloatArray,
    WebGLIntArray,
    WebGLShortArray,
    WebGLByteArray,
    WebGLUnsignedIntArray,
    WebGLUnsignedShortArray,
    WebGLUnsignedByteArray
  ];
  webGLArrayContentGenerators = [randomLength, randomSmallIntArray];
  randomWebGLArray = function() {
    var t = WebGLArrayTypes.random();
    return new t(webGLArrayContentGenerators.random()());
  };

  randomWebGLArrayBuffer = function(buflen) {
    if (buflen == null) buflen = 256;
    var len = Math.floor(Math.random()*buflen)+1;
    var rv;
    try {
      rv = new WebGLArrayBuffer(len);
    } catch(e) {
      log("Error creating WebGLArrayBuffer with length " + len);
      throw(e);
    }
    return rv;
  };

  bufferDataGenerators = [randomLength, randomWebGLArray, randomWebGLArrayBuffer];
  randomBufferData = function() {
    return bufferDataGenerators.random()();
  };

  randomSmallWebGLArray = function(buflen) {
    var t = WebGLArrayTypes.random();
    return new t(Math.floor(Math.random()*(buflen/4))+1);
  };

  bufferSubDataGenerators = [randomSmallWebGLArray, randomWebGLArrayBuffer];
  randomBufferSubData = function(buflen) {
    var data = bufferSubDataGenerators.random()(buflen);
    var offset = Math.floor(Math.random()*(buflen - data.byteLength));
    return {data:data, offset:offset};
  };

  // Returns true if bufData can be passed to GL.bufferData
  isBufferData = function(bufData) {
    if (typeof bufData == 'number')
      return bufData >= 0;
    if (bufData instanceof WebGLArrayBuffer)
      return true;
    return WebGLArrayTypes.some(function(t) {
      return bufData instanceof t;
    });
  };




  // ArgGenerators contains argument generators for WebGL functions.
  // The argument generators are used for running random tests against the WebGL
  // functions.
  //
  // ArgGenerators is an object consisting of functionName : argGen -properties.
  //
  // functionName is a WebGL context function name and the argGen is an argument
  // generator object that encapsulates the requirements to run
  // randomly generated tests on the WebGL function.
  // 
  // An argGen object has the following methods:
  //   - setup    -- set up state for testing the GL function, returns values
  //                 that need cleanup in teardown. Run once before entering a
  //                 test loop.
  //   - teardown -- do cleanup on setup's return values after testing is complete
  //   - generate -- generate a valid set of random arguments for the GL function
  //   - returnValueCleanup -- do cleanup on value returned by the tested GL function
  //   - cleanup  -- do cleanup on generated arguments from generate
  //   - checkArgValidity -- check if passed args are valid. Has a call signature
  //                         that matches generate's return value. Returns true
  //                         if args are valid, false if not.
  //
  //   Example test loop that demonstrates how the function args and return
  //   values flow together:
  //
  //   var setupArgs = argGen.setup();
  //   for (var i=0; i<numberOfTests; i++) {
  //     var generatedArgs = argGen.generate.apply(argGen, setupArgs);
  //     var validArgs = argGen.checkArgValidity.apply(argGen, generatedArgs);
  //     var rv = call the GL function with generatedArgs;
  //     argGen.returnValueCleanup(rv);
  //     argGen.cleanup.apply(argGen, generatedArgs);
  //   }
  //   argGen.teardown.apply(argGen, setupArgs);
  // 
  ArgGenerators = {

  // GL functions in alphabetical order

  // A
  
    activeTexture : {
      generate : function() { return [textureUnit.random()]; },
      checkArgValidity : function(t) { return textureUnit.has(t); },
      teardown : function() { GL.activeTexture(GL.TEXTURE0); }
    },
    attachShader : {
      generate : function() {
        var p = GL.createProgram();
        var sh = GL.createShader(shaderType.random());
        return [p, sh];
      },
      checkArgValidity : function(p, sh) {
        return GL.isProgram(p) && GL.isShader(sh) && !GL.getAttachedShaders(p).has(sh);
      },
      cleanup : function(p, sh) {
        try {GL.detachShader(p,sh);} catch(e) {}
        try {GL.deleteProgram(p);} catch(e) {}
        try {GL.deleteShader(sh);} catch(e) {}
      }
    },

  // B

    bindAttribLocation : {}, // FIXME
    bindBuffer : {
      generate : function(buf) {
        return [bufferTarget.random(), GL.createBuffer()];
      },
      checkArgValidity : function(target, buf) {
        return bufferTarget.has(target) && GL.isBuffer(buf);
      },
      cleanup : function(t, buf, m) {
        GL.deleteBuffer(buf);
      }
    },
    bindFramebuffer : {
      generate : function() {
        return [GL.FRAMEBUFFER, Math.random() > 0.5 ? null : GL.createFramebuffer()];
      },
      checkArgValidity : function(target, fbo) {
        return target == GL.FRAMEBUFFER && (fbo == null || GL.isFramebuffer(fbo));
      },
      cleanup : function(target, fbo) {
        GL.bindFramebuffer(target, null);
        if (fbo)
          GL.deleteFramebuffer(fbo);
      }
    },
    bindRenderbuffer : {
      generate : function() {
        return [GL.RENDERBUFFER, Math.random() > 0.5 ? null : GL.createRenderbuffer()];
      },
      checkArgValidity : function(target, rbo) {
        return target == GL.RENDERBUFFER && (rbo == null || GL.isRenderbuffer(rbo));
      },
      cleanup : function(target, rbo) {
        GL.bindRenderbuffer(target, null);
        if (rbo)
          GL.deleteRenderbuffer(rbo);
      }
    },
    bindTexture : {}, // FIXME
    blendColor : {}, // FIXME
    blendEquation : {}, // FIXME
    blendEquationSeparate : {}, // FIXME
    blendFunc : {}, // FIXME
    blendFuncSeparate : {}, // FIXME
    bufferData : {
      setup : function() {
        var buf = GL.createBuffer();
        var ebuf = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, buf);
        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, ebuf);
        return [buf, ebuf];
      },
      generate : function(buf, ebuf) {
        return [bufferTarget.random(), randomBufferData(), bufferMode.random()];
      },
      checkArgValidity : function(target, bufData, mode) {
        return bufferTarget.has(target) && isBufferData(bufData) && bufferMode.has(mode);
      },
      teardown : function(buf, ebuf) {
        GL.deleteBuffer(buf);
        GL.deleteBuffer(ebuf);
      },
    },
    bufferSubData : {
      setup : function() {
        var buf = GL.createBuffer();
        var ebuf = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, buf);
        GL.bufferData(GL.ARRAY_BUFFER, 256, GL.STATIC_DRAW);
        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, ebuf);
        GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, 256, GL.STATIC_DRAW);
        return [buf, ebuf];
      },
      generate : function(buf, ebuf) {
        var d = randomBufferSubData(256);
        return [bufferTarget.random(), d.offset, d.data];
      },
      checkArgValidity : function(target, offset, data) {
        return bufferTarget.has(target) && offset >= 0 && data.byteLength >= 0 && offset + data.byteLength <= 256;
      },
      teardown : function(buf, ebuf) {
        GL.deleteBuffer(buf);
        GL.deleteBuffer(ebuf);
      },
    },

  // C

    checkFramebufferStatus : {}, // FIXME
    clear : {}, // FIXME
    clearColor : {}, // FIXME
    clearDepth : {}, // FIXME
    clearStencil : {}, // FIXME
    colorMask : {}, // FIXME
    compileShader : {}, // FIXME
    copyTexImage2D : {}, // FIXME
    copyTexSubImage2D : {}, // FIXME
    createBuffer : {
      returnValueCleanup : function(o) { GL.deleteBuffer(o); }
    },
    createFramebuffer : {
      returnValueCleanup : function(o) { GL.deleteFramebuffer(o); }
    },
    createProgram : {
      returnValueCleanup : function(o) { GL.deleteProgram(o); }
    },
    createRenderbuffer : {
      returnValueCleanup : function(o) { GL.deleteRenderbuffer(o); }
    },
    createShader : {
      returnValueCleanup : function(o) { GL.deleteShader(o); }
    },
    createTexture : {
      returnValueCleanup : function(o) { GL.deleteTexture(o); }
    },
    cullFace : {
      generate : function() { return [cullFace.random()]; },
      checkArgValidity : function(f) { return cullFace.has(f); },
      teardown : function() { GL.cullFace(GL.BACK); }
    },

  // D

    deleteBuffer : {
      generate : function() { return [GL.createBuffer()]; },
      checkArgValidity : function(o) { return GL.isBuffer(o); },
      cleanup : function(o) { try { GL.deleteBuffer(o); } catch(e) {} }
    },
    deleteFramebuffer : {
      generate : function() { return [GL.createFramebuffer()]; },
      checkArgValidity : function(o) { return GL.isFramebuffer(o); },
      cleanup : function(o) { try { GL.deleteFramebuffer(o); } catch(e) {} }
    },
    deleteProgram : {
      generate : function() { return [GL.createProgram()]; },
      checkArgValidity : function(o) { return GL.isProgram(o); },
      cleanup : function(o) { try { GL.deleteProgram(o); } catch(e) {} }
    },
    deleteRenderbuffer : {
      generate : function() { return [GL.createRenderbuffer()]; },
      checkArgValidity : function(o) { return GL.isRenderbuffer(o); },
      cleanup : function(o) { try { GL.deleteRenderbuffer(o); } catch(e) {} }
    },
    deleteShader : {
      generate : function() { return [GL.createShader(shaderType.random())]; },
      checkArgValidity : function(o) { return GL.isShader(o); },
      cleanup : function(o) { try { GL.deleteShader(o); } catch(e) {} }
    },
    deleteTexture : {
      generate : function() { return [GL.createTexture()]; },
      checkArgValidity : function(o) { return GL.isTexture(o); },
      cleanup : function(o) { try { GL.deleteTexture(o); } catch(e) {} }
    },
    depthFunc : {}, // FIXME
    depthMask : {}, // FIXME
    depthRange : {}, // FIXME
    detachShader : {}, // FIXME
    disable : {}, // FIXME
    disableVertexAttribArray : {}, // FIXME
    drawArrays : {}, // FIXME
    drawElements : {}, // FIXME

  // E

    enable : {}, // FIXME
    enableVertexAttribArray : {}, // FIXME

  // F
    
    finish : {}, // FIXME
    flush : {}, // FIXME
    framebufferRenderbuffer : {}, // FIXME
    framebufferTexture2D : {}, // FIXME
    frontFace : {}, // FIXME

  // G

    generateMipmap : {}, // FIXME
    getActiveAttrib : {}, // FIXME
    getActiveUniform : {}, // FIXME
    getAttachedShaders : {}, // FIXME
    getAttribLocation : {}, // FIXME
    getParameter : {}, // FIXME
    getBufferParameter : {}, // FIXME
    getError : {}, // FIXME
    getFramebufferAttachmentParameter : {}, // FIXME
    getProgramParameter : {}, // FIXME
    getProgramInfoLog : {}, // FIXME
    getRenderbufferParameter : {}, // FIXME
    getShaderParameter : {}, // FIXME
    getShaderInfoLog : {}, // FIXME
    getShaderSource : {}, // FIXME
    getString : {}, // FIXME
    getTexParameter : {}, // FIXME
    getUniform : {}, // FIXME
    getUniformLocation : {}, // FIXME
    getVertexAttrib : {}, // FIXME
    getVertexAttribOffset : {}, // FIXME

  // H

    hint : {}, // FIXME

  // I

    isBuffer : {}, // FIXME
    isEnabled : {}, // FIXME
    isFramebuffer : {}, // FIXME
    isProgram : {}, // FIXME
    isRenderbuffer : {}, // FIXME
    isShader : {}, // FIXME
    isTexture : {}, // FIXME

  // L

    lineWidth : {}, // FIXME
    linkProgram : {}, // FIXME

  // P
    
    pixelStorei : {}, // FIXME
    polygonOffset : {}, // FIXME

  // R

    readPixels : {}, // FIXME
    renderbufferStorage : {}, // FIXME

  // S

    sampleCoverage : {}, // FIXME
    scissor : {}, // FIXME
    shaderSource : {}, // FIXME
    stencilFunc : {}, // FIXME
    stencilFuncSeparate : {}, // FIXME
    stencilMask : {}, // FIXME
    stencilMaskSeparate : {}, // FIXME
    stencilOp : {}, // FIXME
    stencilOpSeparate : {}, // FIXME

  // T

    texImage2D : {}, // FIXME
    texParameterf : {}, // FIXME
    texParameteri : {}, // FIXME
    texSubImage2D : {}, // FIXME

  // U
    
    uniform1f : {}, // FIXME
    uniform1fv : {}, // FIXME
    uniform1i : {}, // FIXME
    uniform1iv : {}, // FIXME
    uniform2f : {}, // FIXME
    uniform2fv : {}, // FIXME
    uniform2i : {}, // FIXME
    uniform2iv : {}, // FIXME
    uniform3f : {}, // FIXME
    uniform3fv : {}, // FIXME
    uniform3i : {}, // FIXME
    uniform3iv : {}, // FIXME
    uniform4f : {}, // FIXME
    uniform4fv : {}, // FIXME
    uniform4i : {}, // FIXME
    uniform4iv : {}, // FIXME
    uniformMatrix2fv : {}, // FIXME
    uniformMatrix3fv : {}, // FIXME
    uniformMatrix4fv : {}, // FIXME
    useProgram : {}, // FIXME

  // V

    validateProgram : {}, // FIXME
    vertexAttrib1f : {}, // FIXME
    vertexAttrib1fv : {}, // FIXME
    vertexAttrib2f : {}, // FIXME
    vertexAttrib2fv : {}, // FIXME
    vertexAttrib3f : {}, // FIXME
    vertexAttrib3fv : {}, // FIXME
    vertexAttrib4f : {}, // FIXME
    vertexAttrib4fv : {}, // FIXME
    vertexAttribPointer : {}, // FIXME
    viewport : {} // FIXME

  };

  // Calls testFunction numberOfTests times with arguments generated by
  // argGen.generate() (or empty arguments if no generate present).
  //
  // The arguments testFunction is called with are the generated args,
  // the argGen, and what argGen.setup() returned or [] if argGen has not setup
  // method. I.e. testFunction(generatedArgs, argGen, setupVars).
  //
  argGeneratorTestRunner = function(argGen, testFunction, numberOfTests) {
    // do argument generator setup if needed
    var setupVars = argGen.setup ? argGen.setup() : [];
    var error;
    for (var i=0; i<numberOfTests; i++) {
      var failed = false;
      // generate arguments if argGen has a generate method
      var generatedArgs = argGen.generate ? argGen.generate.apply(argGen, setupVars) : [];
      try {
        // call testFunction with the generated args
        testFunction.call(this, generatedArgs, argGen, setupVars);
      } catch (e) {
        failed = true;
        error = e;
      }
      // if argGen needs cleanup for generated args, do it here
      if (argGen.cleanup)
        argGen.cleanup.apply(argGen, generatedArgs);
      if (failed) break;
    }
    // if argGen needs to do a final cleanup for setupVars, do it here
    if (argGen.teardown)
      argGen.teardown.apply(argGen, setupVars);
    if (error) throw(error);
  }
  
</script>

<script type="application/x-javascript">

// Test that all GL functions specified in ArgGenerators work
// when called with randomly generated valid arguments
Tests.testValidArgs = function() {
  var randomTestCount = 100;
  for (var name in ArgGenerators) {
    try {
      var argGen = ArgGenerators[name];
      if (!argGen.generate) continue;
      // test each GL function with randomTestCount randomly generated valid args
      argGeneratorTestRunner(argGen, function(args, gen, setupVars) {
        // if we have an validity checker, assert that the generated args are valid
        if (gen.checkArgValidity)
          assert("Valid args: "+name+"("+args.join(",")+")",
                gen.checkArgValidity.apply(gen, args));
        var rv;
        // assert that GL function works when called with valid args
        assertOk("Calling "+name+"("+args.join(",")+")",
                function(){rv = GL[name].apply(GL, args);});
        // if we need to cleanup the return value, do it here
        // e.g. calling gl.deleteBuffer(rv) after testing gl.createBuffer() above
        if (gen.returnValueCleanup)
          assertOk("Cleaning up return value after "+name+"("+args.join(",")+")",
                   function() { gen.returnValueCleanup(rv); });
      }, randomTestCount);
    } catch(e) {
      testFailed(name, e.name, formatError(e));
    }
  }
}

</script>
<style>canvas{position:absolute;}</style>
</head><body>
</body></html>
