<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../unit.css" />
<script type="application/x-javascript" src="../unit.js"></script>
<script type="application/x-javascript" src="../util.js"></script>

<script type="application/x-javascript">
  /*
    QuickCheck tests for WebGL:

      1. Write a valid arg generator for each function
        1.1. Write valid arg predicates to use with random generator:
             if value passes generator, accept it as valid.
        1.2. Often needs initializing and cleanup:
             setup - generate - cleanup
             gl.createBuffer - test(bindBufferGenerator) - gl.deleteBuffer

      2. Write an invalid arg generator
        2.1. Take valid args, modify an arg until the args no longer pass
             checkArgValidity.
        2.2. Repeat for all args.

      3. Test functions using the generators
        3.1. Args generated with the valid arg generator should pass
             assertOk(f(args))
        3.2. Args generated with the invalid arg generator should pass
             assertFail(f(args))
  */
  GL = document.createElement('canvas').getContext(GL_CONTEXT_ID);
  Array.from = function(o) {
    var a = [];
    for (var i=0; i<o.length; i++)
      a.push(o[i]);
    return a;
  }
  Array.prototype.has = function(v) { return this.indexOf(v) != -1; }
  Array.prototype.random = function() {
    return this[Math.floor(this.length * Math.random())];
  }

  // Creates a constant checker / generator from its arguments.
  // 
  // E.g. if you want a constant checker for the constants 1, 2, and 3, you
  // would do the following:
  // 
  //   var cc = constCheck(1,2,3);
  //   var randomConst = cc.random();
  //   if (cc.has(randomConst))
  //     console.log("randomConst is included in cc's constants");
  // 
  constCheck = function() {
    return Array.from(arguments);
  }

  bufferTarget = constCheck(GL.ARRAY_BUFFER, GL.ELEMENT_ARRAY_BUFFER);
  bufferMode = constCheck(GL.STREAM_DRAW, GL.STATIC_DRAW, GL.DYNAMIC_DRAW);
  cullFace = constCheck(GL.FRONT, GL.BACK, GL.FRONT_AND_BACK);
  shaderType = constCheck(GL.VERTEX_SHADER, GL.FRAGMENT_SHADER);
  textureUnit = constCheck.apply(this, (function(){
    var textureUnits = [];
    var texUnits = GL.getParameter(GL.MAX_TEXTURE_IMAGE_UNITS);
    for (var i=0; i<texUnits; i++) textureUnits.push(GL['TEXTURE'+i]);
    return textureUnits;
  })());

  WebGLArrayTypes = [
    WebGLFloatArray,
    WebGLIntArray,
    WebGLShortArray,
    WebGLByteArray,
    WebGLUnsignedIntArray,
    WebGLUnsignedShortArray,
    WebGLUnsignedByteArray
  ];
  webGLArrayContentGenerators = [randomLength, randomSmallIntArray];
  randomWebGLArray = function() {
    var t = WebGLArrayTypes.random();
    return new t(webGLArrayContentGenerators.random()());
  };

  randomWebGLArrayBuffer = function(buflen) {
    if (buflen == null) buflen = 256;
    return new WebGLArrayBuffer(Math.floor(Math.random()*(buflen+1)));
  };

  bufferDataGenerators = [randomLength, randomWebGLArray, randomWebGLArrayBuffer];
  randomBufferData = function() {
    return bufferDataGenerators.random()();
  };

  randomSmallWebGLArray = function(buflen) {
    var t = WebGLArrayTypes.random();
    return new t(Math.floor(Math.random()*(buflen/4))+1);
  };

  bufferSubDataGenerators = [randomSmallWebGLArray, randomWebGLArrayBuffer];
  randomBufferSubData = function(buflen) {
    var data = bufferSubDataGenerators.random()(buflen);
    var offset = Math.floor(Math.random()*(buflen - data.byteLength));
    return {data:data, offset:offset};
  };

  // Returns true if bufData can be passed to GL.bufferData
  isBufferData = function(bufData) {
    if (typeof bufData == 'number')
      return bufData >= 0;
    if (bufData instanceof WebGLArrayBuffer)
      return true;
    return WebGLArrayTypes.some(function(t) {
      return bufData instanceof t;
    });
  };




  // ArgGenerators contains argument generators for WebGL functions.
  // The argument generators are used for running random tests against the WebGL
  // functions.
  //
  // ArgGenerators is an object consisting of functionName : argGen -properties.
  //
  // functionName is a WebGL context function name and the argGen is an argument
  // generator object that encapsulates the requirements to run
  // randomly generated tests on the WebGL function.
  // 
  // An argGen object has the following methods:
  //   - setup    -- set up state for testing the GL function, returns values
  //                 that need cleanup in teardown. Run once before entering a
  //                 test loop.
  //   - teardown -- do cleanup on setup's return values after testing is complete
  //   - generate -- generate a valid set of random arguments for the GL function
  //   - returnValueCleanup -- do cleanup on value returned by the tested GL function
  //   - cleanup  -- do cleanup on generated arguments from generate
  //   - checkArgValidity -- check if passed args are valid. Has a call signature
  //                         that matches generate's return value. Returns true
  //                         if args are valid, false if not.
  //
  //   Example test loop that demonstrates how the function args and return
  //   values flow together:
  //
  //   var setupArgs = argGen.setup();
  //   for (var i=0; i<numberOfTests; i++) {
  //     var generatedArgs = argGen.generate.apply(argGen, setupArgs);
  //     var validArgs = argGen.checkArgValidity.apply(argGen, generatedArgs);
  //     var rv = call the GL function with generatedArgs;
  //     argGen.returnValueCleanup(rv);
  //     argGen.cleanup.apply(argGen, generatedArgs);
  //   }
  //   argGen.teardown.apply(argGen, setupArgs);
  // 
  ArgGenerators = {
    // buffers
    createBuffer : {
      returnValueCleanup : function(buf) {
        GL.deleteBuffer(buf);
      }
    },
    
    deleteBuffer : {
      generate : function() {
        return [GL.createBuffer()];
      },
      checkArgValidity : function(buf) {
        return GL.isBuffer(buf);
      },
      cleanup : function(buf) {
        try { GL.deleteBuffer(buf); } catch(e) {}
      }
    },

    bindBuffer : {
      generate : function(buf) {
        return [bufferTarget.random(), GL.createBuffer()];
      },
      checkArgValidity : function(target, buf) {
        return bufferTarget.has(target) && GL.isBuffer(buf);
      },
      cleanup : function(t, buf, m) {
        GL.deleteBuffer(buf);
      }
    },

    bufferData : {
      setup : function() {
        var buf = GL.createBuffer();
        var ebuf = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, buf);
        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, ebuf);
        return [buf, ebuf];
      },
      generate : function(buf, ebuf) {
        return [bufferTarget.random(), randomBufferData(), bufferMode.random()];
      },
      checkArgValidity : function(target, bufData, mode) {
        return bufferTarget.has(target) && isBufferData(bufData) && bufferMode.has(mode);
      },
      teardown : function(buf, ebuf) {
        GL.deleteBuffer(buf);
        GL.deleteBuffer(ebuf);
      },
    },

    bufferSubData : {
      setup : function() {
        var buf = GL.createBuffer();
        var ebuf = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, buf);
        GL.bufferData(GL.ARRAY_BUFFER, 256, GL.STATIC_DRAW);
        GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, ebuf);
        GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, 256, GL.STATIC_DRAW);
        return [buf, ebuf];
      },
      generate : function(buf, ebuf) {
        var d = randomBufferSubData(256);
        return [bufferTarget.random(), d.offset, d.data];
      },
      checkArgValidity : function(target, offset, data) {
        return bufferTarget.has(target) && offset >= 0 && data.byteLength >= 0 && offset + data.byteLength <= 256;
      },
      teardown : function(buf, ebuf) {
        GL.deleteBuffer(buf);
        GL.deleteBuffer(ebuf);
      },
    },

    // shaders

    activeTexture : {
      generate : function() {
        return [textureUnit.random()];
      },
      checkArgValidity : function(t) {
        return textureUnit.has(t);
      },
      teardown : function() {
        GL.activeTexture(GL.TEXTURE0);
      }
    },
    attachShader : {},

    bindAttribLocation : {},
    // bindBuffer : {},
    bindFramebuffer : {
      generate : function() {
        return [GL.FRAMEBUFFER, Math.random() > 0.5 ? null : GL.createFramebuffer()];
      },
      checkArgValidity : function(target, fbo) {
        return target == GL.FRAMEBUFFER && (fbo == null || GL.isFramebuffer(fbo));
      },
      cleanup : function(target, fbo) {
        GL.bindFramebuffer(target, null);
        if (fbo)
          GL.deleteFramebuffer(fbo);
      }
    },
    bindRenderbuffer : {},
    bindTexture : {},
    blendColor : {},
    blendEquation : {},
    blendEquationSeparate : {},
    blendFunc : {},
    blendFuncSeparate : {},
    // bufferData : {},
    // bufferSubData : {},

    checkFramebufferStatus : {},
    clear : {},
    clearColor : {},
    clearDepth : {},
    clearStencil : {},
    colorMask : {},
    compileShader : {},
    copyTexImage2D : {},
    copyTexSubImage2D : {},
    // createBuffer : {},
    createFramebuffer : {
      returnValueCleanup : function(o) { GL.deleteFramebuffer(o); }
    },
    createProgram : {
      returnValueCleanup : function(o) { GL.deleteProgram(o); }
    },
    createRenderbuffer : {
      returnValueCleanup : function(o) { GL.deleteRenderbuffer(o); }
    },
    createShader : {
      returnValueCleanup : function(o) { GL.deleteShader(o); }
    },
    createTexture : {
      returnValueCleanup : function(o) { GL.deleteTexture(o); }
    },
    cullFace : {
      generate : function() {
        return [cullFace.random()];
      },
      checkArgValidity : function(f) {
        return cullFace.has(f);
      },
      teardown : function() {
        GL.cullFace(GL.BACK);
      }
    },

    // deleteBuffer : {},
    deleteFramebuffer : {
      generate : function() { return [GL.createFramebuffer()]; },
      checkArgValidity : function(o) { return GL.isFramebuffer(o); },
      cleanup : function(o) { try { GL.deleteFramebuffer(o); } catch(e) {} }
    },
    deleteProgram : {
      generate : function() { return [GL.createProgram()]; },
      checkArgValidity : function(o) { return GL.isProgram(o); },
      cleanup : function(o) { try { GL.deleteProgram(o); } catch(e) {} }
    },
    deleteRenderbuffer : {
      generate : function() { return [GL.createRenderbuffer()]; },
      checkArgValidity : function(o) { return GL.isRenderbuffer(o); },
      cleanup : function(o) { try { GL.deleteRenderbuffer(o); } catch(e) {} }
    },
    deleteShader : {
      generate : function() { return [GL.createShader(shaderType.random())]; },
      checkArgValidity : function(o) { return GL.isShader(o); },
      cleanup : function(o) { try { GL.deleteShader(o); } catch(e) {} }
    },
    deleteTexture : {
      generate : function() { return [GL.createTexture()]; },
      checkArgValidity : function(o) { return GL.isTexture(o); },
      cleanup : function(o) { try { GL.deleteTexture(o); } catch(e) {} }
    },
    depthFunc : {},
    depthMask : {},
    depthRange : {},
    detachShader : {},
    disable : {},
    disableVertexAttribArray : {},
    drawArrays : {},
    drawElements : {},

    enable : {},
    enableVertexAttribArray : {},
    
    finish : {},
    flush : {},
    framebufferRenderbuffer : {},
    framebufferTexture2D : {},
    frontFace : {},

    generateMipmap : {},
    getActiveAttrib : {},
    getActiveUniform : {},
    getAttachedShaders : {},
    getAttribLocation : {},
    getParameter : {},
    getBufferParameter : {},
    getError : {},
    getFramebufferAttachmentParameter : {},
    getProgramParameter : {},
    getProgramInfoLog : {},
    getRenderbufferParameter : {},
    getShaderParameter : {},
    getShaderInfoLog : {},
    getShaderSource : {},
    getString : {},
    getTexParameter : {},
    getUniform : {},
    getUniformLocation : {},
    getVertexAttrib : {},
    getVertexAttribOffset : {},

    hint : {},

    isBuffer : {},
    isEnabled : {},
    isFramebuffer : {},
    isProgram : {},
    isRenderbuffer : {},
    isShader : {},
    isTexture : {},

    lineWidth : {},
    linkProgram : {},
    
    pixelStorei : {},
    polygonOffset : {},

    readPixels : {},
    renderbufferStorage : {},

    sampleCoverage : {},
    scissor : {},
    shaderSource : {},
    stencilFunc : {},
    stencilFuncSeparate : {},
    stencilMask : {},
    stencilMaskSeparate : {},
    stencilOp : {},
    stencilOpSeparate : {},

    texImage2D : {},
    texParameterf : {},
    texParameteri : {},
    texSubImage2D : {},
    
    uniform1f : {},
    uniform1fv : {},
    uniform1i : {},
    uniform1iv : {},
    uniform2f : {},
    uniform2fv : {},
    uniform2i : {},
    uniform2iv : {},
    uniform3f : {},
    uniform3fv : {},
    uniform3i : {},
    uniform3iv : {},
    uniform4f : {},
    uniform4fv : {},
    uniform4i : {},
    uniform4iv : {},
    uniformMatrix2fv : {},
    uniformMatrix3fv : {},
    uniformMatrix4fv : {},
    useProgram : {},
    
    validateProgram : {},
    vertexAttrib1f : {},
    vertexAttrib1fv : {},
    vertexAttrib2f : {},
    vertexAttrib2fv : {},
    vertexAttrib3f : {},
    vertexAttrib3fv : {},
    vertexAttrib4f : {},
    vertexAttrib4fv : {},
    vertexAttribPointer : {},
    viewport : {}

  };

  // Calls testFunction numberOfTests times with arguments generated by
  // argGen.generate() (or empty arguments if no generate present).
  //
  // The arguments testFunction is called with are the generated args,
  // the argGen, and what argGen.setup() returned or [] if argGen has not setup
  // method. I.e. testFunction(generatedArgs, argGen, setupVars).
  //
  argGeneratorTestRunner = function(argGen, testFunction, numberOfTests) {
    // do argument generator setup if needed
    var setupVars = argGen.setup ? argGen.setup() : [];
    var error;
    for (var i=0; i<numberOfTests; i++) {
      var failed = false;
      // generate arguments if argGen has a generate method
      var generatedArgs = argGen.generate ? argGen.generate.apply(argGen, setupVars) : [];
      try {
        // call testFunction with the generated args
        testFunction.call(this, generatedArgs, argGen, setupVars);
      } catch (e) {
        failed = true;
        error = e;
      }
      // if argGen needs cleanup for generated args, do it here
      if (argGen.cleanup)
        argGen.cleanup.apply(argGen, generatedArgs);
      if (failed) break;
    }
    // if argGen needs to do a final cleanup for setupVars, do it here
    if (argGen.teardown)
      argGen.teardown.apply(argGen, setupVars);
    if (error) throw(error);
  }
  
</script>

<script type="application/x-javascript">

// Test that all GL functions specified in ArgGenerators work
// when called with randomly generated valid arguments
Tests.testValidArgs = function() {
  var randomTestCount = 100;
  for (var name in ArgGenerators) {
    var argGen = ArgGenerators[name];
    if (!argGen.generate) continue;
    // test each GL function with randomTestCount randomly generated valid args
    argGeneratorTestRunner(argGen, function(args, gen, setupVars) {
      // if we have an validity checker, assert that the generated args are valid
      if (gen.checkArgValidity)
        assert("Valid args: "+name+"("+args.join(",")+")",
               gen.checkArgValidity.apply(gen, args));
      var rv;
      // assert that GL function works when called with valid args
      assertOk("Calling "+name+"("+args.join(",")+")",
               function(){rv = GL[name].apply(GL, args);});
      // if we need to cleanup the return value, do it here
      // e.g. calling gl.deleteBuffer(rv) after testing gl.createBuffer() above
      if (gen.returnValueCleanup)
        gen.returnValueCleanup(rv);
    }, randomTestCount);
  }
}

</script>
<style>canvas{position:absolute;}</style>
</head><body>
</body></html>
